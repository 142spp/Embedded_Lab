###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       05/Oct/2022  21:53:42
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\newdir\user\main.c
#    Command line =  
#        -f C:\Users\pnu2\AppData\Local\Temp\EW807C.tmp (C:\newdir\user\main.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC C:\newdir\Debug\List -o
#        C:\newdir\Debug\Obj --no_cse --no_unroll --no_inline --no_code_motion
#        --no_tbaa --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\newdir\libraries\CMSIS\DeviceSupport\ -I
#        C:\newdir\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\newdir\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\ -I
#        C:\newdir\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\ -I
#        C:\newdir\user\ -I C:\newdir\user\inc\ -Ol -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  C:\newdir\Debug\List\main.lst
#    Object file  =  C:\newdir\Debug\Obj\main.o
#
###############################################################################

C:\newdir\user\main.c
      1          
      2          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable9  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      3          #include "stm32f10x_exti.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_usart.h"
      6          #include "stm32f10x_rcc.h"
      7          
      8          #include "misc.h"
      9          
     10          /* function prototype */
     11          void RCC_Configure(void);
     12          void GPIO_Configure(void);
     13          void EXTI_Configure(void);
     14          void USART1_Init(void);
     15          void NVIC_Configure(void);
     16          
     17          void EXTI15_10_IRQHandler(void);
     18          
     19          void Delay(void);
     20          
     21          void sendDataUART1(uint16_t data);
     22          
     23          /* Global Variable */

   \                                 In section .bss, align 4
     24          int dif, index, doUartSend;
   \                     dif:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     index:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     doUartSend:
   \   00000000                      DS8 4
     25          
     26          //---------------------------------------------------------------------------------------------------
     27          

   \                                 In section .text, align 2, keep-with-next
     28          void RCC_Configure(void)
     29          {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     30          	// TODO: Enable the APB2 peripheral clock using the function 'RCC_APB2PeriphClockCmd'
     31          	
     32          	/* UART TX/RX port clock enable */
     33              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     34          	/* JoyStick Up/Down port clock enable */
     35              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     36          	/* JoyStick Selection port clock enable */
     37              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2008             MOVS     R0,#+8
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     38          	/* LED port clock enable */
     39              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     40          	/* USART1 clock enable */
     41              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF44F 0x4080      MOV      R0,#+16384
   \   00000028   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     42          	/* Alternate Function IO clock enable */
     43          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     44          }
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
     45          

   \                                 In section .text, align 2, keep-with-next
     46          void GPIO_Configure(void)
     47          {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     48              GPIO_InitTypeDef GPIO_InitStructure;
     49          
     50          	// TODO: Initialize the GPIO pins using the structure 'GPIO_InitTypeDef' and the function 'GPIO_Init'
     51          	
     52              /* JoyStick up, down pin setting */
     53              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_5;
   \   00000002   0x2024             MOVS     R0,#+36
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     54              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000008   0x2048             MOVS     R0,#+72
   \   0000000A   0xF88D 0x0003      STRB     R0,[SP, #+3]
     55              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable9_1  ;; 0x40011000
   \   00000014   0x.... 0x....      BL       GPIO_Init
     56          
     57              /* JoyStick selection pin setting */
     58              // GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
     59              // GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     60              // GPIO_Init(GPIOB, &GPIO_InitStructure);
     61          
     62              /* button pin setting */
     63              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_11;
   \   00000018   0xF44F 0x50C0      MOV      R0,#+6144
   \   0000001C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     64              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000020   0x2048             MOVS     R0,#+72
   \   00000022   0xF88D 0x0003      STRB     R0,[SP, #+3]
     65              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40011400
   \   0000002C   0x.... 0x....      BL       GPIO_Init
     66          
     67              /* LED pin setting*/
     68              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_7;
   \   00000030   0x209C             MOVS     R0,#+156
   \   00000032   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     69              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xF88D 0x0002      STRB     R0,[SP, #+2]
     70              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0xF88D 0x0003      STRB     R0,[SP, #+3]
     71              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable9_2  ;; 0x40011400
   \   00000048   0x.... 0x....      BL       GPIO_Init
     72          	
     73              /* UART pin setting */
     74              //TX
     75              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000004C   0xF44F 0x7000      MOV      R0,#+512
   \   00000050   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     76              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000054   0x2003             MOVS     R0,#+3
   \   00000056   0xF88D 0x0002      STRB     R0,[SP, #+2]
     77              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000005A   0x2018             MOVS     R0,#+24
   \   0000005C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     78              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40010800
   \   00000066   0x.... 0x....      BL       GPIO_Init
     79          	//RX
     80          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000006A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000006E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     81              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000072   0x2048             MOVS     R0,#+72
   \   00000074   0xF88D 0x0003      STRB     R0,[SP, #+3]
     82              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000078   0x4669             MOV      R1,SP
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable9_3  ;; 0x40010800
   \   0000007E   0x.... 0x....      BL       GPIO_Init
     83          	
     84          }
   \   00000082   0xBD01             POP      {R0,PC}          ;; return
     85          

   \                                 In section .text, align 2, keep-with-next
     86          void EXTI_Configure(void)
     87          {
   \                     EXTI_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
     88              EXTI_InitTypeDef EXTI_InitStructure;
     89          
     90              // TODO: Select the GPIO pin (Joystick, button) used as EXTI Line using function 'GPIO_EXTILineConfig'
     91              // TODO: Initialize the EXTI using the structure 'EXTI_InitTypeDef' and the function 'EXTI_Init'
     92          
     93              /* Joystick Down */
     94              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x2002             MOVS     R0,#+2
   \   00000006   0x.... 0x....      BL       GPIO_EXTILineConfig
     95              EXTI_InitStructure.EXTI_Line = EXTI_Line2;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x9000             STR      R0,[SP, #+0]
     96              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0004      STRB     R0,[SP, #+4]
     97              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000014   0x200C             MOVS     R0,#+12
   \   00000016   0xF88D 0x0005      STRB     R0,[SP, #+5]
     98              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xF88D 0x0006      STRB     R0,[SP, #+6]
     99              EXTI_Init(&EXTI_InitStructure);
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x.... 0x....      BL       EXTI_Init
    100          
    101              /* Joystick Up */
    102              GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource5);
   \   00000026   0x2105             MOVS     R1,#+5
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x.... 0x....      BL       GPIO_EXTILineConfig
    103              EXTI_InitStructure.EXTI_Line = EXTI_Line5;
   \   0000002E   0x2020             MOVS     R0,#+32
   \   00000030   0x9000             STR      R0,[SP, #+0]
    104              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF88D 0x0004      STRB     R0,[SP, #+4]
    105              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0xF88D 0x0005      STRB     R0,[SP, #+5]
    106              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xF88D 0x0006      STRB     R0,[SP, #+6]
    107              EXTI_Init(&EXTI_InitStructure);
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x.... 0x....      BL       EXTI_Init
    108          
    109              /* Button */
    110              GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource11);
   \   0000004A   0x210B             MOVS     R1,#+11
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x.... 0x....      BL       GPIO_EXTILineConfig
    111              EXTI_InitStructure.EXTI_Line = EXTI_Line11;
   \   00000052   0xF44F 0x6000      MOV      R0,#+2048
   \   00000056   0x9000             STR      R0,[SP, #+0]
    112              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    113              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
   \   0000005E   0x200C             MOVS     R0,#+12
   \   00000060   0xF88D 0x0005      STRB     R0,[SP, #+5]
    114              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xF88D 0x0006      STRB     R0,[SP, #+6]
    115              EXTI_Init(&EXTI_InitStructure);
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       EXTI_Init
    116          }
   \   00000070   0xBD07             POP      {R0-R2,PC}       ;; return
    117          

   \                                 In section .text, align 2, keep-with-next
    118          void USART1_Init(void)
    119          {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    120          	USART_InitTypeDef USART1_InitStructure;
    121          
    122          	// Enable the USART1 peripheral
    123          	USART_Cmd(USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000006   0x.... 0x....      BL       USART_Cmd
    124          	
    125          	// TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    126          	USART1_InitStructure.USART_BaudRate = 0x1E4;
   \   0000000A   0xF44F 0x70F2      MOV      R0,#+484
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    127              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_RTS;
   \   00000010   0xF44F 0x7080      MOV      R0,#+256
   \   00000014   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    128              USART1_InitStructure.USART_Mode = USART_Mode_Tx;
   \   00000018   0x2008             MOVS     R0,#+8
   \   0000001A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    129              USART1_InitStructure.USART_Parity = USART_Parity_Even;
   \   0000001E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000022   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    130              USART1_InitStructure.USART_StopBits = USART_StopBits_1;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    131              USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    132              USART_Init(USART1, &USART1_InitStructure);
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000036   0x.... 0x....      BL       USART_Init
    133          	
    134          	// TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    135              USART_ITConfig(USART1,USART_IT_RXNE, ENABLE);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000040   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000042   0x.... 0x....      BL       USART_ITConfig
    136          }
   \   00000046   0xB005             ADD      SP,SP,#+20
   \   00000048   0xBD00             POP      {PC}             ;; return
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    139          
    140              NVIC_InitTypeDef NVIC_InitStructure;
    141              
    142              // TODO: fill the arg you want
    143              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000002   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    144          
    145          	// TODO: Initialize the NVIC using the structure 'NVIC_InitTypeDef' and the function 'NVIC_Init'
    146              // Joystick Down
    147              NVIC_InitStructure.NVIC_IRQChannel = EXTI2_IRQn;
   \   0000000A   0x2008             MOVS     R0,#+8
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    148              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0001      STRB     R0,[SP, #+1]
    149              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // TODO
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF88D 0x0002      STRB     R0,[SP, #+2]
    150              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    151              NVIC_Init(&NVIC_InitStructure);
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       NVIC_Init
    152              
    153              // Joystick Up
    154              NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
   \   00000028   0x2017             MOVS     R0,#+23
   \   0000002A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    155              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // TODO
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF88D 0x0001      STRB     R0,[SP, #+1]
    156              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // TODO
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xF88D 0x0002      STRB     R0,[SP, #+2]
    157              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    158              NVIC_Init(&NVIC_InitStructure);
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x.... 0x....      BL       NVIC_Init
    159              
    160              // User S1 Button
    161              NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
   \   00000046   0x2028             MOVS     R0,#+40
   \   00000048   0xF88D 0x0000      STRB     R0,[SP, #+0]
    162              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // TODO
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF88D 0x0001      STRB     R0,[SP, #+1]
    163              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; // TODO
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0xF88D 0x0002      STRB     R0,[SP, #+2]
    164              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    165              NVIC_Init(&NVIC_InitStructure);
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x.... 0x....      BL       NVIC_Init
    166              
    167              // UART1
    168          	// 'NVIC_EnableIRQ' is only required for USART setting
    169              NVIC_EnableIRQ(USART1_IRQn);
   \   00000064   0x2025             MOVS     R0,#+37
   \   00000066   0x.... 0x....      BL       __NVIC_EnableIRQ
    170              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   0000006A   0x2025             MOVS     R0,#+37
   \   0000006C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    171              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; // TODO
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0xF88D 0x0001      STRB     R0,[SP, #+1]
    172              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; // TODO
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0xF88D 0x0002      STRB     R0,[SP, #+2]
    173              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    174              NVIC_Init(&NVIC_InitStructure);
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       NVIC_Init
    175          }
   \   00000088   0xBD01             POP      {R0,PC}          ;; return
    176          

   \                                 In section .text, align 2, keep-with-next
    177          void USART1_IRQHandler() {  // a or b putty input
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    178          	uint16_t word;
    179              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD010             BEQ.N    ??USART1_IRQHandler_0
    180              	// the most recent received data by the USART1 peripheral
    181                  word = USART_ReceiveData(USART1);
   \   00000010   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
    182                  // TODO implement
    183           
    184                  if (word &= ~(0x61));// ex) global var x = 0;
   \   00000016   0xF64F 0x719E      MOVW     R1,#+65438
   \   0000001A   0x4008             ANDS     R0,R1,R0
    185                  if (word &= ~(0x62)) // ex) global var x = 1;
   \   0000001C   0xF64F 0x719D      MOVW     R1,#+65437
   \   00000020   0x4008             ANDS     R0,R1,R0
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD004             BEQ.N    ??USART1_IRQHandler_0
    186                  // clear 'Read data register not empty' flag
    187              	USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \   00000028   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002C   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   0000002E   0x.... 0x....      BL       USART_ClearITPendingBit
    188              }
    189          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void EXTI15_10_IRQHandler(void) { // when the button is pressed
   \                     EXTI15_10_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    192          	if (EXTI_GetITStatus(EXTI_Line11) != RESET) {
   \   00000002   0xF44F 0x6000      MOV      R0,#+2048
   \   00000006   0x.... 0x....      BL       EXTI_GetITStatus
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00D             BEQ.N    ??EXTI15_10_IRQHandler_0
    193          		if (GPIO_ReadInputDataBit(GPIOD, GPIO_Pin_11) == Bit_RESET) {
   \   0000000E   0xF44F 0x6100      MOV      R1,#+2048
   \   00000012   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40011400
   \   00000014   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD106             BNE.N    ??EXTI15_10_IRQHandler_0
    194          			// TODO implement
    195                      doUartSend = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable9_5
   \   00000020   0x6008             STR      R0,[R1, #+0]
    196                  EXTI_ClearITPendingBit(EXTI_Line11);
   \   00000022   0xF44F 0x6000      MOV      R0,#+2048
   \   00000026   0x.... 0x....      BL       EXTI_ClearITPendingBit
    197          	}
    198            }
    199          }
   \                     ??EXTI15_10_IRQHandler_0: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    200          // TODO: Create Joystick interrupt handler functions
    201          

   \                                 In section .text, align 2, keep-with-next
    202          void EXTI2_IRQHandler(void){ // when Joystick down
   \                     EXTI2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    203                if (EXTI_GetITStatus(EXTI_Line2) != RESET) {
   \   00000002   0x2004             MOVS     R0,#+4
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD019             BEQ.N    ??EXTI2_IRQHandler_0
    204                        if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_2) == Bit_RESET ||
    205                            USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET ) {
   \   0000000C   0x2104             MOVS     R1,#+4
   \   0000000E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD006             BEQ.N    ??EXTI2_IRQHandler_1
   \   00000018   0xF240 0x5125      MOVW     R1,#+1317
   \   0000001C   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   0000001E   0x.... 0x....      BL       USART_GetITStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD009             BEQ.N    ??EXTI2_IRQHandler_2
    206          			// TODO implement
    207                            dif != dif;
                                   ^
Warning[Pe174]: expression has no effect
   \                     ??EXTI2_IRQHandler_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable9_6
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable9_6
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ.N    ??EXTI2_IRQHandler_3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B.N      ??EXTI2_IRQHandler_4
   \                     ??EXTI2_IRQHandler_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??EXTI2_IRQHandler_4: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
    208          		}
    209                EXTI_ClearITPendingBit(EXTI_Line2);
   \                     ??EXTI2_IRQHandler_2: (+1)
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x.... 0x....      BL       EXTI_ClearITPendingBit
    210                }
    211          }
   \                     ??EXTI2_IRQHandler_0: (+1)
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    212          

   \                                 In section .text, align 2, keep-with-next
    213          void EXTI9_5_IRQHandler(void){ // when Joystick up or Joystick selection
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    214          	if (EXTI_GetITStatus(EXTI_Line5) != RESET) {
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x.... 0x....      BL       EXTI_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD019             BEQ.N    ??EXTI9_5_IRQHandler_0
    215          		if (GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_5) == Bit_RESET ||
    216                      USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET ) {
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40011000
   \   00000010   0x.... 0x....      BL       GPIO_ReadInputDataBit
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD006             BEQ.N    ??EXTI9_5_IRQHandler_1
   \   00000018   0xF240 0x5125      MOVW     R1,#+1317
   \   0000001C   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   0000001E   0x.... 0x....      BL       USART_GetITStatus
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD009             BEQ.N    ??EXTI9_5_IRQHandler_2
    217          			// TODO implement
    218          			dif != dif;
                 			^
Warning[Pe174]: expression has no effect
   \                     ??EXTI9_5_IRQHandler_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable9_6
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable9_6
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ.N    ??EXTI9_5_IRQHandler_3
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B.N      ??EXTI9_5_IRQHandler_4
   \                     ??EXTI9_5_IRQHandler_3: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??EXTI9_5_IRQHandler_4: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
    219          		}
    220                  EXTI_ClearITPendingBit(EXTI_Line5);
   \                     ??EXTI9_5_IRQHandler_2: (+1)
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x.... 0x....      BL       EXTI_ClearITPendingBit
    221          	}
    222          }
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \   00000040   0xBD01             POP      {R0,PC}          ;; return
    223          
    224          

   \                                 In section .text, align 2, keep-with-next
    225          void Delay(void) {
    226          	int i;
    227          
    228          	for (i = 0; i < 2000000; i++) {}
   \                     Delay: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??Delay_0
   \                     ??Delay_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??Delay_0: (+1)
   \   00000006   0x....             LDR.N    R1,??DataTable9_7  ;; 0x1e8480
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xDBFB             BLT.N    ??Delay_1
    229          }
   \   0000000C   0x4770             BX       LR               ;; return
    230          

   \                                 In section .text, align 2, keep-with-next
    231          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    232          	/* Wait till TC is set */
    233          	while ((USART1->SR & USART_SR_TC) == 0);
   \                     ??sendDataUART1_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x0640             LSLS     R0,R0,#+25
   \   0000000A   0xD5FB             BPL.N    ??sendDataUART1_0
    234          	USART_SendData(USART1, data);
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x....             LDR.N    R0,??DataTable9_4  ;; 0x40013800
   \   00000010   0x.... 0x....      BL       USART_SendData
    235          }
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    236          

   \                                 In section .text, align 2, keep-with-next
    237          int main(void)
    238          {
   \                     main: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    239          
    240              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    241          
    242              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    243          
    244              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    245          
    246              EXTI_Configure();
   \   0000000E   0x.... 0x....      BL       EXTI_Configure
    247          
    248              USART1_Init();
   \   00000012   0x.... 0x....      BL       USART1_Init
    249          
    250              NVIC_Configure();
   \   00000016   0x.... 0x....      BL       NVIC_Configure
    251              GPIOD->BSRR |=  0xF;
   \   0000001A   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40011410
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x000F      ORRS     R0,R0,#0xF
   \   00000022   0x....             LDR.N    R1,??DataTable9_8  ;; 0x40011410
   \   00000024   0x6008             STR      R0,[R1, #+0]
    252              index = 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable9_9
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    253              dif = 1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x....             LDR.N    R1,??DataTable9_6
   \   00000030   0x6008             STR      R0,[R1, #+0]
    254              char msg[] = "Team02.\r\n"; // -*- length = 9;
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x....             LDR.N    R1,??DataTable9_10
   \   00000036   0xE891 0x001C      LDM      R1,{R2-R4}
   \   0000003A   0xE880 0x001C      STM      R0,{R2-R4}
   \   0000003E   0xE010             B.N      ??main_0
    255              while (1) {
    256              	// TODO: implement 
    257                  //GPIOD->BRR = GPIO_BRR_BR2 | GPIO_BRR_BR3 | GPIO_BRR_BR4 | GPIO_BRR_BR7;
    258                  switch(index){
    259                      case 0:
    260                        GPIOD->BSRR |= 0xC; break;
    261                      case 1:
    262                        GPIOD->BSRR |= GPIO_BSRR_BS3; break;
    263                      case 2:
    264                        GPIOD->BSRR |= GPIO_BSRR_BS4; break;
    265                      case 3:
    266                        GPIOD->BSRR |= GPIO_BSRR_BS7; break;
    267                      case -1:
    268                        index = 4; break;
    269                      case 4:
    270                        index = 0; break;
    271                  }       
    272                  if(doUartSend){
    273                      for (int i = 0; i < 9; i++) { sendDataUART1(msg[i]); }
   \                     ??main_1: (+1)
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x5D00             LDRB     R0,[R0, R4]
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x.... 0x....      BL       sendDataUART1
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
   \                     ??main_2: (+1)
   \   0000004C   0x2C09             CMP      R4,#+9
   \   0000004E   0xDBF7             BLT.N    ??main_1
    274                  }
    275                  index += dif;
   \                     ??main_3: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable9_9
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0x....             LDR.N    R0,??DataTable9_6
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1841             ADDS     R1,R0,R1
   \   0000005A   0x....             LDR.N    R0,??DataTable9_9
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    276              	// Delay
    277              	Delay();
   \   0000005E   0x.... 0x....      BL       Delay
   \                     ??main_0: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable9_9
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD00B             BEQ.N    ??main_4
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD010             BEQ.N    ??main_5
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD015             BEQ.N    ??main_6
   \   00000072   0x2803             CMP      R0,#+3
   \   00000074   0xD01A             BEQ.N    ??main_7
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD023             BEQ.N    ??main_8
   \   0000007A   0xF1B0 0x3FFF      CMP      R0,#-1
   \   0000007E   0xD01C             BEQ.N    ??main_9
   \   00000080   0xE022             B.N      ??main_10
   \                     ??main_4: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40011410
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0xF050 0x000C      ORRS     R0,R0,#0xC
   \   0000008A   0x....             LDR.N    R1,??DataTable9_8  ;; 0x40011410
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   \   0000008E   0xE01B             B.N      ??main_10
   \                     ??main_5: (+1)
   \   00000090   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40011410
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000098   0x....             LDR.N    R1,??DataTable9_8  ;; 0x40011410
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE014             B.N      ??main_10
   \                     ??main_6: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40011410
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000000A6   0x....             LDR.N    R1,??DataTable9_8  ;; 0x40011410
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   \   000000AA   0xE00D             B.N      ??main_10
   \                     ??main_7: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40011410
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000B4   0x....             LDR.N    R1,??DataTable9_8  ;; 0x40011410
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   \   000000B8   0xE006             B.N      ??main_10
   \                     ??main_9: (+1)
   \   000000BA   0x2004             MOVS     R0,#+4
   \   000000BC   0x....             LDR.N    R1,??DataTable9_9
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0xE002             B.N      ??main_10
   \                     ??main_8: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x....             LDR.N    R1,??DataTable9_9
   \   000000C6   0x6008             STR      R0,[R1, #+0]
   \                     ??main_10: (+1)
   \   000000C8   0x....             LDR.N    R0,??DataTable9_5
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD0BF             BEQ.N    ??main_3
   \   000000D0   0x2400             MOVS     R4,#+0
   \   000000D2   0xE7BB             B.N      ??main_2
    278              }
    279              return 0;
                     ^
Warning[Pe111]: statement is unreachable
    280          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     doUartSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     dif

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x40011410         DC32     0x40011410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x54 0x65          DC8 "Team02.\015\012"
   \              0x61 0x6D    
   \              0x30 0x32    
   \              0x2E 0x0D    
   \              0x0A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Delay
       8   EXTI15_10_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
       8   EXTI2_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> USART_GetITStatus
       8   EXTI9_5_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> GPIO_ReadInputDataBit
         8   -> USART_GetITStatus
      16   EXTI_Configure
        16   -> EXTI_Init
        16   -> GPIO_EXTILineConfig
       8   GPIO_Configure
         8   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB2PeriphClockCmd
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
      24   main
        24   -> Delay
        24   -> EXTI_Configure
        24   -> GPIO_Configure
        24   -> NVIC_Configure
        24   -> RCC_Configure
        24   -> SystemInit
        24   -> USART1_Init
        24   -> sendDataUART1
       8   sendDataUART1
         8   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      12  ?_0
      14  Delay
      44  EXTI15_10_IRQHandler
      66  EXTI2_IRQHandler
      66  EXTI9_5_IRQHandler
     114  EXTI_Configure
     132  GPIO_Configure
     138  NVIC_Configure
      54  RCC_Configure
      52  USART1_IRQHandler
      74  USART1_Init
      30  __NVIC_EnableIRQ
       4  dif
       4  doUartSend
       4  index
     212  main
      22  sendDataUART1

 
    12 bytes in section .bss
    12 bytes in section .rodata
 1 062 bytes in section .text
 
 1 062 bytes of CODE  memory
    12 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: 3
